# **ğŸ› ï¸ Contribution Rules ğŸ› ï¸**

## **ğŸ”± Create a Fork or Branch ğŸ”±** 
### **ğŸ”´Name it with the feature name you want to add followed by your name.**
### **ğŸ”´Example: addBigIntFunctions-Girgis**

## **ğŸ“File StructureğŸ“‚**
### **ğŸ”´Each topic is in its own folder.**
### **ğŸ”´Each file contains at most 10 functions, solving up to 10 different problems.**

## **ğŸ‘€FunctionsğŸ‘€**
### **ğŸ”´Function names describe their purpose.**
### **ğŸ”´At the beginning of each function, include comments explaining:**
#### **1) The problem the function addresses.**
#### **2) The solution approach.**
#### **2) The time complexity.**
#### **4) If the problem was solved on LeetCode, Codeforces, or another problem-solving platform,**
#### **provide the link in the comments.**


<hr/>

## **AD-Hcoks first 10**

### **1ï¸âƒ£ preFixCowsIds():void**
#### **ğŸ” Implement prefix in three arrays and output queries based on it**


### **2ï¸âƒ£ minMaxSubArrSum():void**
#### **ğŸ” [1,-2,3,4] maxSum can get :[3,4]=7 minSum=[-2]=-2**


### **3ï¸âƒ£ partialSum()**
#### **ğŸ” implement the partialSum**


### **4ï¸âƒ£ maxRestaurant()**
#### **ğŸ” Find the maximum number of people who visited the restaurant at the same time.**


### **5ï¸âƒ£  preFix2DVersion()**
#### **ğŸ” implement the 2D array Prefix**

<hr/>

# **ğŸ“šThe Repo Content SummaryğŸ“š**

## **â•â– Backtracing first 10**

### **1ï¸âƒ£ subsets(int i , int j):void<int>**
#### **ğŸ” Print all the subsets abs={'a','b','c','ab','ac','abc',''}**

### **2ï¸âƒ£ permutation():void<int>**
#### **ğŸ” Using global variables  to print abc={abc,bac,cba,acb,bca,cab}**

### **3ï¸âƒ£ generateBrackets():void**
#### **ğŸ” using size n = 2  print {() (())} all valid brackets**

### **4ï¸âƒ£ nQueens(int row=0):bool**
#### **ğŸ” if you have n*n chess board print all ways that can i place n queens on it**

### **5ï¸âƒ£ sodukoSolver(int i=0 , int j=0):bool**
#### **ğŸ” solve 9*9 grid by soduko game rules**

<hr/>

## **â•â– BigInt first 10**

<hr/>

### **1ï¸âƒ£ sumBigInts(vector<int>n1,vector<int>n2):vector<int>**
#### **ğŸ” Sum two digit vectors and return the resulting vector**
#### **ğŸ” There is also a string version: sumBigInts(string s1, string s2): string**

### **2ï¸âƒ£ bigFactorial(int n):vector<int>**
#### **ğŸ” Calculate the factorial of a number up to a 1000-digit number**

## **â•â– BitWise first 10**

### **1ï¸âƒ£ isOdd(Long Long): bool**
#### **ğŸ” Check if the given number is odd or not**

### **2ï¸âƒ£ isPowerOfTwo(Long Long n): bool**
#### **ğŸ” If the number is a power of 2, return true; otherwise, return false**

### **3ï¸âƒ£ countBits(Long Long n): int**
#### **ğŸ” Given any number, output the number of ones in its binary representation**

### **4ï¸âƒ£ getIthBit(Long Long n, int index): bool**
#### **ğŸ” Return the ith bit for a given number**

### **5ï¸âƒ£ setIthBit(Long Long &n, int index, bool seterValue=0): void**
#### **ğŸ” Set the ith bit to 0 or 1, changing the original number**

### **6ï¸âƒ£ clearFirstNthBits(Long Long &n, int endPos): void**
#### **ğŸ” Set the first n bits to zeros (inclusive)**

### **7ï¸âƒ£ clearRangeOfBits(Long Long &n, int startPos, int endPos): void**
#### **ğŸ” From startPos to endPos, set all bits to zeros (inclusive)**

### **8ï¸âƒ£ setRangeOfBits(Long Long &n, int startPos, int endPos, bool seterValue): void**
#### **ğŸ” From startPos to endPos, set all bits to one or zero (inclusive)**

### **9ï¸âƒ£ convertToDecimal(string bin): Long Long**

### **ğŸ”Ÿ convertToBinary(Long Long n): Long Long**
#### **ğŸ” There is also convertToBinary(Long Long n): string a string version**
<hr/>

## **â•â– DataStructures Files**

### **1ï¸âƒ£ arrStack.c++**

### **2ï¸âƒ£ Bst.c++**

### **3ï¸âƒ£ circularQueue.c++**

### **4ï¸âƒ£ linkedQueue.c++**

### **5ï¸âƒ£ list.c++**

### **6ï¸âƒ£ Pariorityqueue.c++**

### **7ï¸âƒ£ queue.c++**

### **8ï¸âƒ£ stack.c++**

### **9ï¸âƒ£ graph.c++**

<hr/>

## **â•â– Sorts**

### **1ï¸âƒ£ mergeSort(vector<int>arr):vector<int>**

### **2ï¸âƒ£ bubbleSort(vector<int>&arr):void**

### **3ï¸âƒ£ selectionSort(vector<int> & arr):void**

<hr/>

## **STL**

### **1ï¸âƒ£ list.c++**
### **2ï¸âƒ£ vector.c++**
### **3ï¸âƒ£ algorithm.c++**
### **4ï¸âƒ£ lambda.c++**
### **5ï¸âƒ£ deque.c++**




## **â•â– BitWise second 10**

<hr/>

### **1ï¸âƒ£ unique2NPlus1Seq(vector<int> seq):int**
##### **ğŸ” Given 2n+1 numbers all apear twice except one number return that unique number**
##### **ğŸ” Thers is second version return pair of unique numbers in 2N+2 seq**

### **2ï¸âƒ£ unique3NPlus1Seq(vector<int>seq):int**
##### **ğŸ” Almost all numbers apear 3 times except one number i want that number**

### **3ï¸âƒ£ generateAllSubsequences(string str):vector<string>**
##### **ğŸ” Given str="abc" return vector={"","a","b","c","ab","ac","bc","abc"}**

### **4ï¸âƒ£ travellingSalesMan(vector<vector<int>>&dist,int setOfBits,int startingNode):int**
##### **ğŸ” Recursive function to get shortest path of a graph (A->B->C->D->A)**

<hr/>

## **â•â–DP (Dynamic Programming) first 10**
#### **Empty For Now**




<hr/>




## **â•â– Greedy first 10**

### **1ï¸âƒ£ maxActivitiesICanDo(vector<pair<int,int>>&v):int**
##### **ğŸ” give array of pairs (start time , end time) return max number of activities you can do**

## **â•â– Number Theory first 10**
<hr/>

### **1ï¸âƒ£ isPrime(ll n): bool**
##### **ğŸ” Fast solution to check if a number is prime**

### **2ï¸âƒ£ sieve(ll n, vector<bool>& isPrime): void**
##### **ğŸ” Generate a boolean array where each index indicates if it is a prime number**

### **3ï¸âƒ£ factorise(ll n): void**
##### **ğŸ” Print the factorization of the number**

### **4ï¸âƒ£ factoriseWithSieve(ll n, vector<ll>& sieve): void**
##### **ğŸ” Precompute primes using a sieve and print the factorization of the number**

### **5ï¸âƒ£ mygcd(int a , int b):int**

### **6ï¸âƒ£ nCr(int n , int r):long long**

### **7ï¸âƒ£ nPr(int n , int r):long long**

### **8ï¸âƒ£ pascalTriangle(vector<vector<int>>&table):void**
##### **ğŸ” Give you the 2D vector for paascalTriangle to precompute nCr**

### **9ï¸âƒ£ countBST(int n  ,map<int,int>dp={{0,0}}):int**
##### **ğŸ” calculate how many different bunary trees can be created if i have n nodes**

<hr/>

## **â•â– Recursion first 10**
<hr/>

### **1ï¸âƒ£ fac(int n):int**
##### **ğŸ” return factorial of anumber**

### **2ï¸âƒ£ fib(int n ):int**
##### **ğŸ” return the nth fibonacci sequence**

### **3ï¸âƒ£ isSorted(vector<int>&v , int size):bool**
##### **ğŸ”return true or false if the vector sorted or not**

### **4ï¸âƒ£printInc(int n):void**
##### **ğŸ” print from 1->n**

### **5ï¸âƒ£printDec(int n):void**
##### **ğŸ” print from n->1**

### **6ï¸âƒ£slowPow(int a , int n):int**
##### **ğŸ” return a^n in O(n) complexity**

### **7ï¸âƒ£ fastPow(double x, long long  n):double**
##### **ğŸ” return a^n in O(log(n)) complexity**

### **8ï¸âƒ£ tiling(int n):int**
##### **ğŸ”describe in the function by comments**

### **9ï¸âƒ£ binaryStrings(int n, bool prevIsOne = false):int**
##### **ğŸ” print number of ways to perform all binary strings of size n two consecutive ones**

### **ğŸ”Ÿ subsets(string s,string sub=""):void**
##### **ğŸ”give "abc" print 'a','b','c','ab','ac','ca','abc'**
<hr/>

## **â•â– Two Pointers 10**

### **1ï¸âƒ£ binarySearch(vector<int>& v , int target):int\***
##### **ğŸ” return true if the target found else return  false**

### **2ï¸âƒ£ lowerBound(vector<int> &v , int target):int\***
##### **ğŸ” return the first number gerater or equal to the target**

### **3ï¸âƒ£ upperBound(vector<int> &v , int target):int\***
##### **ğŸ” return the first element gerater then  the target**
 
### **4ï¸âƒ£firstLastApear(vector<int>& v, int target):pair<int*,int*>**
##### **ğŸ” return the first and last apear of the target**


## **â•â– WorkWithFiles first 10**
<hr/>

### **1ï¸âƒ£ overwriteFile(const string& filename):void**

### **2ï¸âƒ£ appendToFile(const string& filename):void**

### **3ï¸âƒ£ readNumbersFromFile(const string& filename):void**

### **4ï¸âƒ£ appendTextToFile(const string& filename):void**

### **5ï¸âƒ£ readLinesFromFile(const string& filename):void**
##### **ğŸ” Each function has two versions to cover different syntax**

